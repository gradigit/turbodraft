#!/usr/bin/env bash
set -euo pipefail

if [[ $# -lt 1 ]]; then
  echo "usage: turbodraft-editor [--line N] [--column N] <file>" >&2
  exit 2
fi

script_dir="$(dirname -- "${BASH_SOURCE[0]}")"
# Resolve symlinks to find the real repo root.
_src="${BASH_SOURCE[0]}"
while [[ -L "$_src" ]]; do
  _dir="$(dirname -- "$_src")"
  _src="$(readlink -- "$_src")"
  [[ "$_src" != /* ]] && _src="$_dir/$_src"
done
script_dir="$(cd -- "$(dirname -- "$_src")" && pwd)"
repo_root="${script_dir%/*}"
local_turbodraft="$repo_root/.build/release/turbodraft"
local_turbodraft_open="$repo_root/.build/release/turbodraft-open"
file=""
line=""
column=""

parse_args() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --line)
        [[ $# -ge 2 ]] || { echo "turbodraft-editor: missing value for --line" >&2; exit 2; }
        line="$2"
        shift 2
        ;;
      --column)
        [[ $# -ge 2 ]] || { echo "turbodraft-editor: missing value for --column" >&2; exit 2; }
        column="$2"
        shift 2
        ;;
      +[0-9]*)
        line="${1#+}"
        shift
        ;;
      --)
        shift
        if [[ $# -gt 0 ]]; then
          file="$1"
          shift
        fi
        ;;
      -*)
        shift
        ;;
      *)
        file="$1"
        shift
        ;;
    esac
  done
}

parse_args "$@"

if [[ -z "$file" ]]; then
  echo "turbodraft-editor: missing file argument" >&2
  exit 2
fi

detect_terminal_bundle_id() {
  if [[ -n "${TURBODRAFT_TERMINAL_BUNDLE_ID:-}" ]]; then
    printf '%s\n' "$TURBODRAFT_TERMINAL_BUNDLE_ID"
    return 0
  fi
  case "${TERM_PROGRAM:-}" in
    Apple_Terminal) printf '%s\n' "com.apple.Terminal" ;;
    iTerm.app) printf '%s\n' "com.googlecode.iterm2" ;;
    WezTerm) printf '%s\n' "com.github.wez.wezterm" ;;
    ghostty|Ghostty) printf '%s\n' "com.mitchellh.ghostty" ;;
    *) return 1 ;;
  esac
}

# Capture frontmost app in background — not on the critical path to editor open.
_frontmost_file="${TMPDIR:-/tmp}/.turbodraft-frontmost-$$"
if command -v osascript >/dev/null 2>&1; then
  osascript -e 'tell application "System Events" to get bundle identifier of first process whose frontmost is true' \
    >"$_frontmost_file" 2>/dev/null &
  _frontmost_pid=$!
else
  _frontmost_pid=""
fi

run_editor() {
  # Large timeout so long editing sessions don't fail Ctrl+G unexpectedly.
  local timeout_ms="86400000"
  local open_args=(--path "$file" --wait --timeout-ms "$timeout_ms")
  if [[ -n "$line" ]]; then
    open_args+=(--line "$line")
  fi
  if [[ -n "$column" ]]; then
    open_args+=(--column "$column")
  fi

  # Prefer turbodraft-open (C binary, ~20ms faster — no Swift runtime).
  # Fall back to turbodraft (Swift CLI) if not available.
  if [[ -x "$local_turbodraft_open" ]]; then
    "$local_turbodraft_open" "${open_args[@]}"
    return $?
  fi

  if command -v turbodraft-open >/dev/null 2>&1; then
    turbodraft-open "${open_args[@]}"
    return $?
  fi

  if [[ -x "$local_turbodraft" ]]; then
    "$local_turbodraft" open "${open_args[@]}"
    return $?
  fi

  if command -v turbodraft >/dev/null 2>&1; then
    turbodraft open "${open_args[@]}"
    return $?
  fi

  echo "turbodraft editor hook not available (need turbodraft or turbodraft-open in PATH)" >&2
  return 127
}

rc=0
if ! run_editor; then
  rc=$?
fi

# Restore focus to the terminal app after editor closes.
if command -v osascript >/dev/null 2>&1; then
  if terminal_bundle_id="$(detect_terminal_bundle_id)"; then
    osascript -e "tell application id \"$terminal_bundle_id\" to activate" >/dev/null 2>&1 || true
  else
    # Reap background osascript and read its result.
    previous_frontmost_app=""
    if [[ -n "${_frontmost_pid:-}" ]]; then
      wait "$_frontmost_pid" 2>/dev/null || true
      previous_frontmost_app="$(cat "$_frontmost_file" 2>/dev/null || true)"
      rm -f "$_frontmost_file"
    fi
    if [[ -n "$previous_frontmost_app" ]]; then
      osascript -e "tell application id \"$previous_frontmost_app\" to activate" >/dev/null 2>&1 || true
    fi
  fi
fi

# Clean up background osascript if it's still around.
if [[ -n "${_frontmost_pid:-}" ]]; then
  wait "$_frontmost_pid" 2>/dev/null || true
  rm -f "$_frontmost_file"
fi

exit $rc
